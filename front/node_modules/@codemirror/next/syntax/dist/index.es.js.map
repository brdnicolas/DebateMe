{"version":3,"file":"index.es.js","sources":["../src/indent.ts","../src/fold.ts","../src/syntax.ts","../src/props.ts"],"sourcesContent":["import {Line} from \"../../text\"\nimport {NodeType, NodeProp, Subtree, Tree} from \"lezer-tree\"\nimport {EditorState, Syntax} from \"../../state\"\n\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a number. That number may be -1, to indicate that no\n/// definitive indentation can be determined, or a column number to\n/// which the given line should be indented.\nexport const indentNodeProp = new NodeProp<(context: IndentContext) => number>()\n\nexport function syntaxIndentation(syntax: Syntax) {\n  return EditorState.indentation.of((state: EditorState, pos: number) => {\n    return computeIndentation(state, syntax.getTree(state), pos)\n  })\n}\n\n// Compute the indentation for a given position from the syntax tree.\nfunction computeIndentation(state: EditorState, ast: Tree, pos: number) {\n  let tree: Subtree | null = ast.resolve(pos)\n\n  // Enter previous nodes that end in empty error terms, which means\n  // they were broken off by error recovery, so that indentation\n  // works even if the constructs haven't been finished.\n  for (let scan = tree!, scanPos = pos;;) {\n    let last = scan.childBefore(scanPos)\n    if (!last) break\n    if (last.type.prop(NodeProp.error) && last.start == last.end) {\n      tree = scan\n      scanPos = last.start\n    } else {\n      scan = last\n      scanPos = scan.end + 1\n    }\n  }\n\n  for (; tree; tree = tree.parent) {\n    let strategy = indentStrategy(tree.type) || (tree.parent == null ? topIndent : null)\n    if (strategy) return strategy(new IndentContext(state, pos, tree))\n  }\n  return -1\n}\n\nfunction indentStrategy(type: NodeType) {\n  let strategy = type.prop(indentNodeProp)\n  if (!strategy) {\n    let delim = type.prop(NodeProp.delim)\n    if (delim) return delimitedIndent({closing: delim.split(\" \")[1]})\n  }\n  return strategy\n}\n\nfunction topIndent() { return 0 }\n\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nexport class IndentContext {\n  /// @internal\n  constructor(\n    /// The editor state.\n    readonly state: EditorState,\n    /// The position at which indentation is being computed.\n    readonly pos: number,\n    /// The syntax tree node for which the indentation strategy is\n    /// registered.\n    readonly node: Subtree) {}\n\n  /// The indent unit (number of spaces per indentation level).\n  get unit() { return this.state.indentUnit }\n\n  /// Get the text directly after `this.pos`, either the entire line\n  /// or the next 50 characters, whichever is shorter.\n  get textAfter() {\n    return this.state.doc.slice(this.pos, Math.min(this.pos + 50, this.state.doc.lineAt(this.pos).end)).match(/^\\s*(.*)/)![1]\n  }\n\n  /// find the column position (taking tabs into account) of the given\n  /// position in the given string.\n  countColumn(line: string, pos: number) {\n    // FIXME use extending character information\n    if (pos < 0) pos = line.length\n    let tab = this.state.tabSize\n    for (var i = 0, n = 0;;) {\n      let nextTab = line.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= pos) return n + (pos - i)\n      n += nextTab - i\n      n += tab - (n % tab)\n      i = nextTab + 1\n    }\n  }\n\n  /// Find the indentation column of the given document line.\n  lineIndent(line: Line) {\n    let text = line.slice(0, Math.min(50, line.length, this.node.start > line.start ? this.node.start - line.start : 1e8))\n    return this.countColumn(text, text.search(/\\S/))\n  }\n\n  /// Get the indentation at the reference line for `this.tree`, which\n  /// is the line on which it starts, unless there is a node that is\n  /// _not_ a parent of this node covering the start of that line. If\n  /// so, the line at the start of that node is tried, again skipping\n  /// on if it is covered by another such node.\n  get baseIndent() {\n    let line = this.state.doc.lineAt(this.node.start)\n    // Skip line starts that are covered by a sibling (or cousin, etc)\n    for (;;) {\n      let atBreak = this.node.resolve(line.start)\n      while (atBreak.parent && atBreak.parent.start == atBreak.start) atBreak = atBreak.parent\n      if (isParent(atBreak, this.node)) break\n      line = this.state.doc.lineAt(atBreak.start)\n    }\n    return this.lineIndent(line)\n  }\n\n  /// Find the column for the given position.\n  column(pos: number) {\n    let line = this.state.doc.lineAt(pos)\n    return this.countColumn(line.slice(0, pos - line.start), pos - line.start)\n  }\n}\n\nfunction isParent(parent: Subtree, of: Subtree) {\n  for (let cur: Subtree | null = of; cur; cur = cur.parent) if (parent == cur) return true\n  return false\n}\n\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context: IndentContext) {\n  let tree = context.node\n  let openToken = tree.childAfter(tree.start)\n  if (!openToken) return null\n  let openLine = context.state.doc.lineAt(openToken.start)\n  for (let pos = openToken.end;;) {\n    let next = tree.childAfter(pos)\n    if (!next) return null\n    if (!next.type.prop(NodeProp.skipped))\n      return next.start < openLine.end ? openToken : null\n    pos = next.end\n  }\n}\n\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nexport function delimitedIndent({closing, align = true, units = 1}: {closing: string, align?: boolean, units?: number}) {\n  return (context: IndentContext) => {\n    let closed = context.textAfter.slice(0, closing.length) == closing\n    let aligned = align ? bracketedAligned(context) : null\n    if (aligned) return closed ? context.column(aligned.start) : context.column(aligned.end)\n    return context.baseIndent + (closed ? 0 : context.unit * units)\n  }\n}\n\n/// An indentation strategy that aligns a node content to its base\n/// indentation.\nexport const flatIndent = (context: IndentContext) => context.baseIndent\n\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nexport function continuedIndent({except, units = 1}: {except?: RegExp, units?: number} = {}) {\n  return (context: IndentContext) => {\n    let matchExcept = except && except.test(context.textAfter)\n    return context.baseIndent + (matchExcept ? 0 : units * context.unit)\n  }\n}\n","import {NodeProp, Subtree} from \"lezer-tree\"\nimport {EditorState, Syntax} from \"../../state\"\n\n/// This node prop is used to associate folding information with node\n/// types. Given a subtree, it should check whether that tree is\n/// foldable and return the range that can be collapsed when it is.\nexport const foldNodeProp = new NodeProp<(subtree: Subtree, state: EditorState) => ({from: number, to: number} | null)>()\n\nexport function syntaxFolding(syntax: Syntax) {\n  return EditorState.foldable.of((state: EditorState, start: number, end: number) => {\n    let inner = syntax.getTree(state).resolve(end)\n    let found: null | {from: number, to: number} = null\n    for (let cur: Subtree | null = inner; cur; cur = cur.parent) {\n      if (cur.end <= end || cur.start > end) continue\n      if (found && cur.start < start) break\n      let prop = cur.type.prop(foldNodeProp)\n      if (prop) {\n        let value = prop(cur, state)\n        if (value && value.from <= end && value.from >= start && value.to > end) found = value\n      }\n    }\n    return found\n  })\n}\n","import {Parser, InputStream, ParseContext} from \"lezer\"\nimport {Tree, Subtree, NodeProp} from \"lezer-tree\"\nimport {Text, TextIterator} from \"../../text\"\nimport {EditorState, StateField, Transaction, Syntax, languageData, Extension, Annotation} from \"../../state\"\nimport {ViewPlugin, ViewUpdate, EditorView} from \"../../view\"\nimport {syntaxIndentation} from \"./indent\"\nimport {syntaxFolding} from \"./fold\"\n\n/// A [syntax provider](#state.Syntax) based on a\n/// [Lezer](https://lezer.codemirror.net) parser.\nexport class LezerSyntax implements Syntax {\n  readonly field: StateField<SyntaxState>\n  /// The extension value to install this provider.\n  readonly extension: Extension\n\n  /// Create a syntax instance for the given parser. You'll usually\n  /// want to use the\n  /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)\n  /// method to register CodeMirror-specific syntax node props in the\n  /// parser, before passing it to this constructor.\n  constructor(readonly parser: Parser) {\n    let setSyntax = Annotation.define<SyntaxState>()\n    this.field = StateField.define<SyntaxState>({\n      create(state) { return SyntaxState.advance(Tree.empty, parser, state.doc) },\n      update(value, tr) { return value.apply(tr, parser, setSyntax) }\n    })\n    this.extension = [\n      EditorState.syntax.of(this),\n      this.field,\n      ViewPlugin.define(view => new HighlightWorker(view, this, setSyntax)),\n      syntaxIndentation(this),\n      syntaxFolding(this)\n    ]\n  }\n\n  getTree(state: EditorState) {\n    return state.field(this.field).tree\n  }\n\n  parsePos(state: EditorState) {\n    return state.field(this.field).upto\n  }\n\n  ensureTree(state: EditorState, upto: number, timeout = 100): Tree | null {\n    let field = state.field(this.field)\n    if (field.upto >= upto) return field.updatedTree\n    if (!field.parse) field.startParse(this.parser, state.doc)\n\n    if (field.parse!.pos < upto) {\n      let done = work(field.parse!, timeout, upto)\n      if (done) return field.stopParse(done, state.doc.length)\n    }\n\n    return field.parse!.pos < upto ? null : field.stopParse()\n  }\n\n  get docNodeType() { return this.parser.group.types[1] }\n\n  languageDataAt<Interface = any>(state: EditorState, pos: number) {\n    let type = this.parser.group.types[1]\n    if (this.parser.hasNested) {\n      let tree = this.getTree(state)\n      let target: Subtree | null = tree.resolve(pos)\n      while (target) {\n        if (target.type.prop(NodeProp.top)) {\n          type = target.type\n          break\n        }\n        target = target.parent\n      }\n    }\n    return (type.prop(languageData) || nothing) as Interface\n  }\n}\n\nconst nothing = {}\n\nclass DocStream implements InputStream {\n  cursor: TextIterator\n  cursorPos = 0\n  string = \"\"\n\n  constructor(readonly doc: Text, readonly length: number = doc.length) {\n    this.cursor = doc.iter()\n  }\n\n  get(pos: number) {\n    if (pos >= this.length) return -1\n    let stringStart = this.cursorPos - this.string.length\n    if (pos < stringStart || pos >= this.cursorPos) {\n      if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n        this.cursor = this.doc.iter()\n        this.cursorPos = 0\n      }\n      this.string = this.cursor.next(pos - this.cursorPos).value\n      this.cursorPos = pos + this.string.length\n      stringStart = this.cursorPos - this.string.length\n    }\n    return this.string.charCodeAt(pos - stringStart)\n  }\n\n  read(from: number, to: number) {\n    let stringStart = this.cursorPos - this.string.length\n    if (from < stringStart || to >= this.cursorPos)\n      return this.doc.slice(from, to)\n    else\n      return this.string.slice(from - stringStart, to - stringStart)\n  }\n\n  clip(at: number) {\n    return new DocStream(this.doc, at)\n  }\n}\n\nconst enum Work {\n  // Milliseconds of work time to perform immediately for a state doc change\n  Apply = 25,\n  // Minimum amount of work time to perform in an idle callback\n  MinSlice = 25,\n  // Amount of work time to perform in pseudo-thread when idle callbacks aren't supported\n  Slice = 100,\n  // Maximum pause (timeout) for the pseudo-thread\n  Pause = 200,\n  // Don't parse beyond this point unless explicitly requested to with `ensureTree`.\n  MaxPos = 5e6\n}\n\nfunction work(parse: ParseContext, time: number, upto: number = Work.MaxPos) {\n  let endTime = Date.now() + time\n  for (;;) {\n    let done = parse.advance()\n    if (done) return done\n    if (parse.pos > upto || Date.now() > endTime) return null\n  }\n}\n\nfunction takeTree(parse: ParseContext, base: Tree) {\n  let parsed = parse.forceFinish()\n  let after = base.applyChanges([{fromA: 0, toA: parse.pos, fromB: 0, toB: parse.pos}])\n  return parsed.append(after)\n}\n\nclass SyntaxState {\n  public updatedTree: Tree\n  public parse: ParseContext | null = null\n\n  constructor(public tree: Tree, public upto: number) {\n    this.updatedTree = tree\n  }\n\n  static advance(tree: Tree, parser: Parser, doc: Text) {\n    let parse = parser.startParse(new DocStream(doc), {cache: tree})\n    let done = work(parse, Work.Apply)\n    return done ? new SyntaxState(done, doc.length) : new SyntaxState(takeTree(parse, tree), parse.pos)\n  }\n\n  apply(tr: Transaction, parser: Parser, annotation: Annotation<SyntaxState>) {\n    let given = tr.annotation(annotation)\n    return given || (!tr.docChanged && this) || SyntaxState.advance(\n      (this.parse ? takeTree(this.parse, this.updatedTree) : this.updatedTree).applyChanges(tr.changes.changedRanges()),\n      parser, tr.doc)\n  }\n\n  startParse(parser: Parser, doc: Text) {\n    this.parse = parser.startParse(new DocStream(doc), {cache: this.updatedTree})\n  }\n\n  stopParse(tree?: Tree | null, upto?: number) {\n    if (!tree) tree = takeTree(this.parse!, this.updatedTree)\n    this.updatedTree = tree\n    this.upto = upto ?? this.parse!.pos\n    this.parse = null\n    return tree\n  }\n}\n\ntype Deadline = {timeRemaining(): number, didTimeout: boolean}\ntype IdleCallback = (deadline?: Deadline) => void\n\nlet requestIdle: (callback: IdleCallback, options: {timeout: number}) => number =\n  typeof window != \"undefined\" && (window as any).requestIdleCallback ||\n  ((callback: IdleCallback, {timeout}: {timeout: number}) => setTimeout(callback, timeout))\nlet cancelIdle: (id: number) => void = typeof window != \"undefined\" && (window as any).cancelIdleCallback || clearTimeout\n\n// FIXME figure out some way to back off from full re-parses when the\n// document is largeâ€”you could waste a lot of battery re-parsing a\n// multi-megabyte document every time you insert a backtick, even if\n// it happens in the background.\n\nclass HighlightWorker {\n  working: number = -1\n\n  constructor(readonly view: EditorView, \n              readonly syntax: LezerSyntax,\n              readonly setSyntax: Annotation<SyntaxState>) {\n    this.work = this.work.bind(this)\n    this.scheduleWork()\n  }\n\n  update(update: ViewUpdate) {\n    if (update.docChanged) this.scheduleWork()\n  }\n\n  scheduleWork() {\n    if (this.working > -1) return\n    let {state} = this.view, field = state.field(this.syntax.field)\n    if (field.upto >= state.doc.length) return\n    this.working = requestIdle(this.work, {timeout: Work.Pause})\n  }\n\n  work(deadline?: Deadline) {\n    this.working = -1\n    let {state} = this.view, field = state.field(this.syntax.field)\n    if (field.upto >= state.doc.length) return\n    if (!field.parse) field.startParse(this.syntax.parser, state.doc)\n    let done = work(field.parse!, deadline ? Math.max(Work.MinSlice, deadline.timeRemaining()) : Work.Slice)\n    if (done || field.parse!.badness > .8)\n      this.view.dispatch(state.t().annotate(this.setSyntax, new SyntaxState(\n        field.stopParse(done, state.doc.length), state.doc.length)))\n    else\n      this.scheduleWork()\n  }\n\n  destroy() {\n    if (this.working >= 0) cancelIdle(this.working)\n  }\n}\n","import {NodeProp} from \"lezer-tree\"\n\nfunction mkMatchProp() { return new NodeProp<string[]>({deserialize(str) { return str.split(\" \") }}) }\n\n/// A node prop that encodes information about which other nodes match\n/// this node as delimiters. Should hold a space-separated list of\n/// node names of the closing nodes that match this node.\nexport const openNodeProp = mkMatchProp()\n\n/// Like `openNodeProp`, but for closing nodes. Should hold a\n/// space-separated list of opening node names that match this closing\n/// delimiter.\nexport const closeNodeProp = mkMatchProp()\n"],"names":[],"mappings":"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"}