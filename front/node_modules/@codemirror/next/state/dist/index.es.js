import { charType, Text } from '../../text';
export { Text } from '../../text';
import { NodeProp, Tree } from 'lezer-tree';

/// A single selection range. When
/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)
/// is enabled, a [selection](#state.EditorSelection) may hold
/// multiple ranges. By default, selections hold exactly one range.
class SelectionRange {
    /// Create a range. `head` defaults to `anchor` when not given.
    constructor(
    /// The anchor of the range—the side that doesn't move when you
    /// extend it.
    anchor, 
    /// The head of the range, which is moved when the range is
    /// [extended](#state.SelectionRange.extend).
    head = anchor) {
        this.anchor = anchor;
        this.head = head;
    }
    /// The lower side of the range.
    get from() { return Math.min(this.anchor, this.head); }
    /// The upper side of the range.
    get to() { return Math.max(this.anchor, this.head); }
    /// True when `anchor` and `head` are at the same position.
    get empty() { return this.anchor == this.head; }
    /// Map this range through a mapping.
    map(mapping) {
        let anchor = mapping.mapPos(this.anchor), head = mapping.mapPos(this.head);
        if (anchor == this.anchor && head == this.head)
            return this;
        else
            return new SelectionRange(anchor, head);
    }
    /// Extend this range to cover at least `from` to `to`.
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return new SelectionRange(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return new SelectionRange(this.anchor, head);
    }
    /// Compare this range to another range.
    eq(other) {
        return this.anchor == other.anchor && this.head == other.head;
    }
    /// Return a JSON-serializable object representing the range.
    toJSON() { return this; }
    /// Convert a JSON representation of a range to a `SelectionRange`
    /// instance.
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return new SelectionRange(json.anchor, json.head);
    }
    /// @internal FIXME export?
    static groupAt(state, pos, bias = 1) {
        // FIXME at some point, take language-specific identifier characters into account
        let line = state.doc.lineAt(pos), linePos = pos - line.start;
        if (line.length == 0)
            return new SelectionRange(pos);
        if (linePos == 0)
            bias = 1;
        else if (linePos == line.length)
            bias = -1;
        let read = linePos + (bias < 0 ? -1 : 0), type = charType(line.slice(read, read + 1));
        let from = pos, to = pos;
        for (let lineFrom = linePos; lineFrom > 0 && charType(line.slice(lineFrom - 1, lineFrom)) == type; lineFrom--)
            from--;
        for (let lineTo = linePos; lineTo < line.length && charType(line.slice(lineTo, lineTo + 1)) == type; lineTo++)
            to++;
        return new SelectionRange(to, from);
    }
}
/// An editor selection holds one or more selection ranges.
class EditorSelection {
    /// @internal
    constructor(
    /// The ranges in the selection, sorted by position. Ranges cannot
    /// overlap (but they may touch, if they aren't empty).
    ranges, 
    /// The index of the _primary_ range in the selection (which is
    /// usually the range that was added last).
    primaryIndex = 0) {
        this.ranges = ranges;
        this.primaryIndex = primaryIndex;
    }
    /// Map a selection through a mapping. Mostly used to adjust the
    /// selection position for changes.
    map(mapping) {
        return EditorSelection.create(this.ranges.map(r => r.map(mapping)), this.primaryIndex);
    }
    /// Compare this selection to another selection.
    eq(other) {
        if (this.ranges.length != other.ranges.length ||
            this.primaryIndex != other.primaryIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i]))
                return false;
        return true;
    }
    /// Get the primary selection range. Usually, you should make sure
    /// your code applies to _all_ ranges, by using transaction methods
    /// like [`forEachRange`](#state.transaction.forEachRange).
    get primary() { return this.ranges[this.primaryIndex]; }
    /// Make sure the selection only has one range. Returns a selection
    /// holding only the primary range from this selection.
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.primary]);
    }
    /// Extend this selection with an extra range.
    addRange(range, primary = true) {
        return EditorSelection.create([range].concat(this.ranges), primary ? 0 : this.primaryIndex + 1);
    }
    /// Replace a given range with another range, and then normalize the
    /// selection to merge and sort ranges if necessary.
    replaceRange(range, which = this.primaryIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.primaryIndex);
    }
    /// Convert this selection to an object that can be serialized to
    /// JSON.
    toJSON() {
        return this.ranges.length == 1 ? this.ranges[0].toJSON() :
            { ranges: this.ranges.map(r => r.toJSON()), primaryIndex: this.primaryIndex };
    }
    /// Create a selection from a JSON representation.
    static fromJSON(json) {
        if (json && Array.isArray(json.ranges)) {
            if (typeof json.primaryIndex != "number" || json.primaryIndex >= json.ranges.length)
                throw new RangeError("Invalid JSON representation for EditorSelection");
            return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.primaryIndex);
        }
        return new EditorSelection([SelectionRange.fromJSON(json)]);
    }
    /// Create a selection holding a single range.
    static single(anchor, head = anchor) {
        return new EditorSelection([new SelectionRange(anchor, head)], 0);
    }
    /// Sort and merge the given set of ranges, creating a valid
    /// selection.
    static create(ranges, primaryIndex = 0) {
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return normalized(ranges.slice(), primaryIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, primaryIndex);
    }
}
function normalized(ranges, primaryIndex = 0) {
    let primary = ranges[primaryIndex];
    ranges.sort((a, b) => a.from - b.from);
    primaryIndex = ranges.indexOf(primary);
    for (let i = 1; i < ranges.length; i++) {
        let range = ranges[i], prev = ranges[i - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            let from = prev.from, to = Math.max(range.to, prev.to);
            if (i <= primaryIndex)
                primaryIndex--;
            ranges.splice(--i, 2, range.anchor > range.head ? new SelectionRange(to, from) : new SelectionRange(from, to));
        }
    }
    return new EditorSelection(ranges, primaryIndex);
}
function checkSelection(selection, doc) {
    for (let range of selection.ranges)
        if (range.to > doc.length)
            throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/// A facet is a value that is assicated with a state and can be
/// influenced by any number of extensions. Extensions can provide
/// input values for the facet, and the facet combines those into an
/// output value.
///
/// Examples of facets are the theme styles associated with an editor
/// (which are all stored) or the tab size (which is reduced to a
/// single value, using the input with the hightest precedence).
class Facet {
    constructor(
    /// @internal
    combine, 
    /// @internal
    compareInput, 
    /// @internal
    compare, isStatic) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        /// @internal
        this.id = nextID++;
        this.default = combine([]);
    }
    /// Define a new facet.
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static);
    }
    /// Returns an extension that adds the given value for this facet.
    of(value) {
        return new FacetProvider([], this, 0 /* Static */, value);
    }
    /// Create an extension that computes a value for the facet from a
    /// state. You must take care to declare the parts of the state that
    /// this value depends on, since your function is only called again
    /// for a new state when one of those parts changed.
    ///
    /// In most cases, you'll want to use
    /// [`StateField.provide`](#state.StateField^provide) instead.
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Single */, get);
    }
    /// Create an extension that computes zero or more values for this
    /// facet from a state.
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Multi */, get);
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        let getter = this.value;
        let compare = this.facet.compareInput;
        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((addresses[dep.id] & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return (state, tr) => {
            if (!tr || tr.reconfigured) {
                state.values[idx] = getter(state);
                return 1 /* Changed */;
            }
            else {
                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selectionSet)) ||
                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);
                if (!depChanged)
                    return 0;
                let newVal = getter(state), oldVal = tr.startState.values[idx];
                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))
                    return 0;
                state.values[idx] = newVal;
                return 1 /* Changed */;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    return (state, tr) => {
        let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;
        let changed = oldAddr == null;
        for (let dynAddr of dynamic) {
            if (ensureAddr(state, dynAddr) & 1 /* Changed */)
                changed = true;
        }
        if (!changed)
            return 0;
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2 /* Multi */)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        let newVal = facet.combine(values);
        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))
            return 0;
        state.values[idx] = newVal;
        return 1 /* Changed */;
    };
}
/// Fields can store additional information in an editor state, and
/// keep it in sync with the rest of the state.
class StateField {
    constructor(
    /// @internal
    id, createF, updateF, compareF, 
    /// @internal
    facets) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.facets = facets;
    }
    /// Define a state field.
    static define(config) {
        return new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), []);
    }
    provide(facet, get, prec) {
        let provider = facet.compute([this], get ? state => get(state.field(this)) : state => state.field(this));
        return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)));
    }
    /// Extends the field to provide zero or more input values for the
    /// given facet.
    provideN(facet, get, prec) {
        let provider = facet.computeN([this], state => get(state.field(this)));
        return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)));
    }
    /// @internal
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return (state, tr) => {
            let oldIdx = !tr ? null : tr.reconfigured ? tr.startState.config.address[this.id] >> 1 : idx;
            if (oldIdx == null) {
                state.values[idx] = this.createF(state);
                return 1 /* Changed */;
            }
            else {
                let oldVal = tr.startState.values[oldIdx], value = this.updateF(oldVal, tr, state);
                if (this.compareF(oldVal, value))
                    return 0;
                state.values[idx] = value;
                return 1 /* Changed */;
            }
        };
    }
}
/// By default extensions are registered in the order they are
/// provided in a flattening of the nested arrays that were provided.
/// Individual extension values can be assigned a precedence to
/// override this. Extensions that do not have a precedence set get
/// the precedence of the nearest parent with a precedence, or
/// [`Default`](#state.Precedence.Default) if there is no such parent.
/// The final ordering of extensions is determined by first sorting by
/// precedence and then by order within each precedence.
class Precedence {
    constructor(
    /// @internal
    val) {
        this.val = val;
    }
    /// Tag an extension with this precedence.
    set(extension) {
        return new PrecExtension(extension, this.val);
    }
}
/// A precedence below the default precedence, which will cause
/// default-precedence extensions to override it even if they are
/// specified later in the extension ordering.
Precedence.Fallback = new Precedence(3);
/// The regular default precedence.
Precedence.Default = new Precedence(2);
/// A higher-than-default precedence.
Precedence.Extend = new Precedence(1);
/// Precedence above the `Default` and `Extend` precedences.
Precedence.Override = new Precedence(0);
function maybePrec(prec, ext) {
    return prec == null ? ext : prec.set(ext);
}
class PrecExtension {
    constructor(e, prec) {
        this.e = e;
        this.prec = prec;
    }
}
class GroupExtension {
    constructor(extension, group) {
        this.extension = extension;
        this.group = group;
    }
}
/// Extension groups can be used to make a configuration dynamic.
/// [Wrapping](#state.ExtensionGroup.of) an extension in a group
/// allows you to later replace it with
/// [`Transaction.replaceExtension`](#state.Transaction.replaceExtension).
/// A given group may only occur once within a given configuration.
class ExtensionGroup {
    /// Define a new group. The name is used only for debugging
    /// purposes.
    constructor(name) {
        this.name = name;
    }
    /// Tag the given extension with this group.
    of(extension) { return new GroupExtension(extension, this); }
}
class Configuration {
    constructor(source, replacements, dynamicSlots, address, staticValues) {
        this.source = source;
        this.replacements = replacements;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.statusTemplate = [];
        while (this.statusTemplate.length < staticValues.length)
            this.statusTemplate.push(0 /* Uninitialized */);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(extension, replacements = new Map, oldState) {
        let fields = [];
        let facets = Object.create(null);
        for (let ext of flatten(extension, replacements)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            if (providers.every(p => p.type == 0 /* Static */)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                let value = facet.combine(providers.map(p => p.value));
                let oldAddr = oldState ? oldState.config.address[facet.id] : null;
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (facet.compare(value, oldVal))
                        value = oldVal;
                }
                staticValues.push(value);
            }
            else {
                for (let p of providers) {
                    if (p.type == 0 /* Static */) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        return new Configuration(extension, replacements, dynamicSlots.map(f => f(address)), address, staticValues);
    }
}
function flatten(extension, replacements) {
    let result = [[], [], [], []];
    let seen = new Set();
    let groupsSeen = new Set();
    (function inner(ext, prec) {
        if (seen.has(ext))
            return;
        seen.add(ext);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof GroupExtension) {
            if (groupsSeen.has(ext.group))
                throw new RangeError(`Duplicate use of group '${ext.group.name}' in extensions`);
            groupsSeen.add(ext.group);
            inner(replacements.get(ext.group) || ext.extension, prec);
        }
        else if (ext.extension) {
            inner(ext.extension, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.e, ext.prec);
        }
        else {
            result[prec].push(ext);
            if (ext instanceof StateField)
                inner(ext.facets, prec);
        }
    })(extension, Precedence.Default.val);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2 /* Computed */;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4 /* Computing */)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* Computed */)
        return status;
    state.status[idx] = 4 /* Computing */;
    let changed = state.config.dynamicSlots[idx](state, state.applying);
    return state.status[idx] = 2 /* Computed */ | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const allowMultipleSelections = Facet.define({
    combine: values => values.some(v => v),
    static: true
});
let annotationID = 0;
/// Annotations are tagged values that are used to add metadata to
/// transactions in an extensible way.
class Annotation {
    constructor() {
        /// @internal
        this.id = annotationID++;
    }
    /// Define a new type of annotation.
    static define() { return new Annotation(); }
}
/// A node prop that can be stored on a grammar's top node to
/// associate information with the language. Different extension might
/// use different properties from this object (which they typically
/// export as an interface).
const languageData = new NodeProp();
// FIXME add a view plugin that schedules background parsing
// FIXME add a way to be notified when the document is fully parsed

const empty = [];
/// Distinguishes different ways in which positions can be mapped.
var MapMode;
(function (MapMode) {
    /// Map a position to a valid new position, even when its context
    /// was deleted.
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /// Return a negative number if a deletion happens across the
    /// position. This number will be `-(newPos + 1)`, where `newPos` is
    /// the result you'd get with `MapMode.Simple`.
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /// Return a negative number if the character _before_ the position
    /// is deleted. The result is encoded the same way as with
    /// `MapMode.TrackDel`.
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /// Return a negative number if the character _after_ the position is
    /// deleted.
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
})(MapMode || (MapMode = {}));
/// A change description describes a document change. This is usually
/// used as a superclass of [`Change`](#state.Change), but can be used
/// to store change data without storing the replacement string
/// content.
class ChangeDesc {
    /// Create a description that replaces the text between positions
    /// `from` and `to` with a new string of length `length`.
    constructor(
    /// The start position of the change.
    from, 
    /// The end of the change (as a pre-change document position).
    to, 
    /// The length of the replacing content.
    length) {
        this.from = from;
        this.to = to;
        this.length = length;
    }
    /// Get the change description of the inverse of this change.
    get invertedDesc() { return new ChangeDesc(this.from, this.from + this.length, this.to - this.from); }
    /// @internal
    mapPos(pos, bias = -1, mode = MapMode.Simple) {
        let { from, to, length } = this;
        if (pos < from)
            return pos;
        if (pos > to)
            return pos + (length - (to - from));
        if (pos == to || pos == from) {
            if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)
                return -pos - 1;
            return (from == to ? bias <= 0 : pos == from) ? from : from + length;
        }
        pos = from + (bias <= 0 ? 0 : length);
        return mode != MapMode.Simple ? -pos - 1 : pos;
    }
    /// Return a JSON-serializeable object representing this value.
    toJSON() { return this; }
    /// Create a change description from its JSON representation.
    static fromJSON(json) {
        if (!json || typeof json.from != "number" || typeof json.to != "number" || typeof json.length != "number")
            throw new RangeError("Invalid JSON representation for ChangeDesc");
        return new ChangeDesc(json.from, json.to, json.length);
    }
}
/// Change objects describe changes to the document.
class Change extends ChangeDesc {
    /// Create a change that replaces `from` to `to` with `text`. The
    /// text is given as an array of lines. When it doesn't span lines,
    /// the array has a single element. When it does, a new element is
    /// added for every line. It should never have zero elements.
    constructor(from, to, 
    /// The replacement content.
    text) {
        super(from, to, textLength(text));
        this.from = from;
        this.to = to;
        this.text = text;
    }
    /// Create the inverse of this change when applied to the given
    /// document. `change.invert(doc).apply(change.apply(doc))` gets you
    /// the same document as the original `doc`.
    invert(doc) {
        return new Change(this.from, this.from + this.length, doc.sliceLines(this.from, this.to));
    }
    /// Apply this change to the given content, returning an updated
    /// version of the document.
    apply(doc) {
        return doc.replace(this.from, this.to, this.text);
    }
    /// Map this change through a mapping, producing a new change that
    /// can be applied to a post-mapping document. May return null if
    /// the mapping completely replaces the region this change would
    /// apply to.
    map(mapping) {
        let from = mapping.mapPos(this.from, 1), to = mapping.mapPos(this.to, -1);
        return from > to ? null : new Change(from, to, this.text);
    }
    /// A change description for this change.
    get desc() { return new ChangeDesc(this.from, this.to, this.length); }
    /// Produce a JSON-serializable object representing this change.
    toJSON() {
        return { from: this.from, to: this.to, text: this.text };
    }
    /// Read a change instance from its JSON representation.
    static fromJSON(json) {
        if (!json || typeof json.from != "number" || typeof json.to != "number" ||
            !Array.isArray(json.text) || json.text.length == 0 || json.text.some((val) => typeof val != "string"))
            throw new RangeError("Invalid JSON representation for Change");
        return new Change(json.from, json.to, json.text);
    }
}
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
/// A change set holds a sequence of changes or change descriptions.
class ChangeSet {
    /// @internal
    constructor(
    /// The changes in this set.
    changes, 
    /// @internal
    mirror = empty) {
        this.changes = changes;
        this.mirror = mirror;
        this._changedRanges = null;
    }
    /// The number of changes in the set.
    get length() {
        return this.changes.length;
    }
    /// Change sets can track which changes are inverses of each other,
    /// to allow robust position mapping in situations where changes are
    /// undone and then redone again. This queries which change is the
    /// mirror image of a given change (by index).
    getMirror(n) {
        for (let i = 0; i < this.mirror.length; i++)
            if (this.mirror[i] == n)
                return this.mirror[i + (i % 2 ? -1 : 1)];
        return null;
    }
    /// Append a change to this set, returning an extended set. `mirror`
    /// may be the index of a change already in the set, which
    /// [mirrors](#state.ChangeSet.getMirror) the new change.
    append(change, mirror) {
        return new ChangeSet(this.changes.concat(change), mirror != null ? this.mirror.concat(this.length, mirror) : this.mirror);
    }
    /// Append another change set to this one.
    appendSet(changes) {
        return changes.length == 0 ? this :
            this.length == 0 ? changes :
                new ChangeSet(this.changes.concat(changes.changes), this.mirror.concat(changes.mirror.map(i => i + this.length)));
    }
    /// @internal
    mapPos(pos, bias = -1, mode = MapMode.Simple) {
        return this.mapInner(pos, bias, mode, 0, this.length);
    }
    /// @internal
    mapInner(pos, bias, mode, fromI, toI) {
        let dir = toI < fromI ? -1 : 1;
        let recoverables = null;
        let hasMirrors = this.mirror.length > 0, rec, mirror, deleted = false;
        for (let i = fromI - (dir < 0 ? 1 : 0), endI = toI - (dir < 0 ? 1 : 0); i != endI; i += dir) {
            let { from, to, length } = this.changes[i];
            if (dir < 0) {
                let len = to - from;
                to = from + length;
                length = len;
            }
            if (pos < from)
                continue;
            if (pos > to) {
                pos += length - (to - from);
                continue;
            }
            // Change touches this position
            if (recoverables && (rec = recoverables[i]) != null) { // There's a recovery for this change, and it applies
                pos = from + rec;
                continue;
            }
            if (hasMirrors && (mirror = this.getMirror(i)) != null &&
                (dir > 0 ? mirror > i && mirror < toI : mirror < i && mirror >= toI)) { // A mirror exists
                if (pos > from && pos < to) { // If this change deletes the position, skip forward to the mirror
                    i = mirror;
                    pos = this.changes[i].from + (pos - from);
                    continue;
                }
                (recoverables || (recoverables = {}))[mirror] = pos - from;
            }
            if (pos > from && pos < to) {
                if (mode != MapMode.Simple)
                    deleted = true;
                pos = bias <= 0 ? from : from + length;
            }
            else {
                if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)
                    deleted = true;
                pos = (from == to ? bias <= 0 : pos == from) ? from : from + length;
            }
        }
        return deleted ? -pos - 1 : pos;
    }
    /// Check whether these changes touch a given range. When one of the
    /// changes entirely covers the range, the string `"cover"` is
    /// returned.
    touchesRange(from, to) {
        let result = false;
        for (let change of this.changes) {
            if (change.to >= from && change.from <= to) {
                if (change.from < from && change.to > to)
                    return "cover";
                result = true;
            }
            let diff = change.length - (change.to - change.from);
            if (from > change.from)
                from += diff;
            if (to > change.to)
                to += diff;
        }
        return result;
    }
    /// Get a partial [mapping](#state.Mapping) covering part of this
    /// change set.
    partialMapping(from, to = this.length) {
        if (from == 0 && to == this.length)
            return this;
        return new PartialMapping(this, from, to);
    }
    /// Summarize this set of changes as a minimal sequence of changed
    /// ranges, sored by position. For example, if you have changes
    /// deleting between 1 and 4 and inserting a character at 1, the
    /// result would be a single range saying 1 to 4 in the old doc was
    /// replaced with range 1 to 2 in the new doc.
    changedRanges() {
        if (this._changedRanges)
            return this._changedRanges;
        let set = [];
        for (let i = 0; i < this.length; i++) {
            let change = this.changes[i];
            let fromA = change.from, toA = change.to, fromB = change.from, toB = change.from + change.length;
            if (i < this.length - 1) {
                let mapping = this.partialMapping(i + 1);
                fromB = mapping.mapPos(fromB, 1);
                toB = mapping.mapPos(toB, -1);
            }
            if (i > 0) {
                let mapping = this.partialMapping(i, 0);
                fromA = mapping.mapPos(fromA, 1);
                toA = mapping.mapPos(toA, -1);
            }
            new ChangedRange(fromA, toA, fromB, toB).addToSet(set);
        }
        return this._changedRanges = set;
    }
    /// Convert a set of changes to a set of change descriptions.
    get desc() {
        if (this.changes.length == 0 || this.changes[0] instanceof ChangeDesc)
            return this;
        return new ChangeSet(this.changes.map(ch => ch.desc), this.mirror);
    }
    /// Create a JSON-serializable representation of this change set.
    toJSON() {
        let changes = this.changes.map(change => change.toJSON());
        return this.mirror.length == 0 ? changes : { mirror: this.mirror, changes };
    }
    /// Read a change set from its JSON representation.
    static fromJSON(ChangeType, json) {
        let mirror, changes;
        if (Array.isArray(json)) {
            mirror = empty;
            changes = json;
        }
        else if (!json || !Array.isArray(json.mirror) || !Array.isArray(json.changes)) {
            throw new RangeError("Invalid JSON representation for ChangeSet");
        }
        else {
            ({ mirror, changes } = json);
        }
        return new ChangeSet(changes.map((ch) => ChangeType.fromJSON(ch)), mirror);
    }
}
/// The empty change set.
ChangeSet.empty = new ChangeSet(empty);
class PartialMapping {
    constructor(changes, from, to) {
        this.changes = changes;
        this.from = from;
        this.to = to;
    }
    mapPos(pos, bias = -1, mode = MapMode.Simple) {
        return this.changes.mapInner(pos, bias, mode, this.from, this.to);
    }
}
/// A changed range represents a replacement as two absolute ranges,
/// one pointing into the old document (the replaced content) and one
/// pointing into the new document (the content that replaces it).
class ChangedRange {
    // FIXME store unchanged ranges instead?
    constructor(
    /// The start of the replaced range in the old document.
    fromA, 
    /// The end of the replaced range in the old document.
    toA, 
    /// The start of the replacing range in the new document.
    fromB, 
    /// The end of the replacing range in the new document.
    toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    /// @internal
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    /// @internal
    // FIXME used by view. Document?
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    /// The difference in document length created by this change
    /// (positive when the document grew).
    get lenDiff() { return (this.toB - this.fromB) - (this.toA - this.fromA); }
    /// @internal
    static mapPos(pos, bias, changes) {
        let off = 0;
        for (let range of changes) {
            if (pos < range.fromA)
                break;
            if (pos <= range.toA) {
                let side = range.toA == range.fromA ? bias : pos == range.fromA ? -1 : pos == range.toA ? 1 : bias;
                return side < 0 ? range.fromB : range.toB;
            }
            off = range.toB - range.toA;
        }
        return pos + off;
    }
}

/// Changes to the editor state are grouped into transactions.
/// Usually, a user action creates a single transaction, which may
/// contain zero or more document changes. Create a transaction by
/// calling [`EditorState.t`](#state.EditorState.t).
///
/// Transactions are mutable, and usually built up piece by piece with
/// updating methods and method chaining (most methods return the
/// transaction itself). Once they are
/// [applied](#state.Transaction.apply), they can't be updated
/// anymore.
class Transaction {
    /// @internal
    constructor(
    /// The state from which the transaction starts.
    startState, time = Date.now()) {
        this.startState = startState;
        /// The document changes made by this transaction.
        this.changes = ChangeSet.empty;
        /// The document versions after each of the changes.
        this.docs = [];
        this._annotations = Object.create(null);
        this.flags = 0;
        /// @internal
        this.reconfigureData = null;
        this.state = null;
        this.selection = startState.selection;
        this._annotations[Transaction.time.id] = time;
    }
    /// The document at the end of the transaction.
    get doc() {
        let last = this.docs.length - 1;
        return last < 0 ? this.startState.doc : this.docs[last];
    }
    /// Add annotations to this transaction. Annotations can provide
    /// additional information about the transaction.
    annotate(annotation, value) {
        this.ensureOpen();
        this._annotations[annotation.id] = value;
        return this;
    }
    /// Get the value of the given annotation type, if any.
    annotation(annotation) {
        return this._annotations[annotation.id];
    }
    /// Add a change to this transaction. If `mirror` is given, it
    /// should be the index (in `this.changes.changes`) at which the
    /// mirror image of this change sits.
    change(change, mirror) {
        this.ensureOpen();
        if (change.from == change.to && change.length == 0)
            return this;
        if (change.from < 0 || change.to < change.from || change.to > this.doc.length)
            throw new RangeError(`Invalid change ${change.from} to ${change.to}`);
        this.changes = this.changes.append(change, mirror);
        this.docs.push(change.apply(this.doc));
        this.selection = this.selection.map(change);
        return this;
    }
    /// Indicates whether the transaction changed the document.
    get docChanged() {
        return this.changes.length > 0;
    }
    /// Add a change replacing the given document range with the given
    /// content.
    replace(from, to, text) {
        return this.change(new Change(from, to, typeof text == "string" ? this.startState.splitLines(text) : text));
    }
    /// Replace all selection ranges with the given content.
    replaceSelection(text) {
        let content = typeof text == "string" ? this.startState.splitLines(text) : text;
        return this.forEachRange(range => {
            let change = new Change(range.from, range.to, content);
            this.change(change);
            return new SelectionRange(range.from + change.length);
        });
    }
    /// Run the given function for each selection range. The method will
    /// map the ranges to reflect deletions/insertions that happen
    /// before them. At the end, set the new selection to the ranges
    /// returned by the function (again, automatically mapped to for
    /// changes that happened after them).
    forEachRange(f) {
        let sel = this.selection, start = this.changes.length, newRanges = [];
        for (let range of sel.ranges) {
            let before = this.changes.length;
            let result = f(range.map(this.changes.partialMapping(start)), this);
            if (this.changes.length > before) {
                let mapping = this.changes.partialMapping(before);
                for (let i = 0; i < newRanges.length; i++)
                    newRanges[i] = newRanges[i].map(mapping);
            }
            newRanges.push(result);
        }
        return this.setSelection(EditorSelection.create(newRanges, sel.primaryIndex));
    }
    /// Update the selection.
    setSelection(selection) {
        this.ensureOpen();
        if (!this.startState.facet(allowMultipleSelections))
            selection = selection.asSingle();
        checkSelection(selection, this.doc);
        this.selection = selection;
        this.flags |= 1 /* SelectionSet */;
        return this;
    }
    /// Tells you whether this transaction explicitly sets a new
    /// selection (as opposed to just mapping the selection through
    /// changes).
    get selectionSet() {
        return (this.flags & 1 /* SelectionSet */) > 0;
    }
    /// Set a flag on this transaction that indicates that the editor
    /// should scroll the selection into view after applying it.
    scrollIntoView() {
        this.ensureOpen();
        this.flags |= 2 /* ScrollIntoView */;
        return this;
    }
    /// Query whether the selection should be scrolled into view after
    /// applying this transaction.
    get scrolledIntoView() {
        return (this.flags & 2 /* ScrollIntoView */) > 0;
    }
    /// Provice new content for a given [extension
    /// group](#state.ExtensionGroup) in the current configuration. (If
    /// the group isn't present in the configuration, this will not have
    /// any effect.)
    replaceExtension(group, content) {
        this.ensureOpen();
        if (!this.reconfigureData) {
            let replaced = new Map();
            this.startState.config.replacements.forEach((ext, group) => replaced.set(group, ext));
            this.reconfigureData = { base: this.startState.config.source, replaced };
        }
        this.reconfigureData.replaced.set(group, content);
        return this;
    }
    /// Move to an entirely new state configuration.
    reconfigure(extension) {
        this.ensureOpen();
        this.reconfigureData = { base: extension, replaced: new Map };
        return this;
    }
    /// Indicates whether the transaction reconfigures the state.
    get reconfigured() {
        return this.reconfigureData != null;
    }
    ensureOpen() {
        if (this.state)
            throw new Error("Transactions may not be modified after being applied");
    }
    /// Apply this transaction, computing a new editor state. May be
    /// called multiple times (the result is cached). The transaction
    /// cannot be further modified after this has been called.
    apply() {
        return this.state || (this.state = this.startState.applyTransaction(this));
    }
    /// Create a set of changes that undo the changes made by this
    /// transaction.
    invertedChanges() {
        if (!this.changes.length)
            return ChangeSet.empty;
        let changes = [], set = this.changes;
        for (let i = set.length - 1; i >= 0; i--)
            changes.push(set.changes[i].invert(i == 0 ? this.startState.doc : this.docs[i - 1]));
        return new ChangeSet(changes, set.mirror.length ? set.mirror.map(i => set.length - i - 1) : set.mirror);
    }
}
/// Annotation used to store transaction timestamps.
Transaction.time = Annotation.define();
/// Annotation used to indicate that this transaction shouldn't
/// clear the goal column, which is used during vertical cursor
/// motion (so that moving over short lines doesn't reset the
/// horizontal position to the end of the shortest line). Should
/// generally only be set by commands that perform vertical motion.
Transaction.preserveGoalColumn = Annotation.define();
/// Annotation used to associate a transaction with a user interface
/// event. The view will set this to...
///
///  - `"paste"` when pasting content
///  - `"cut"` when cutting
///  - `"drop"` when content is inserted via drag-and-drop
///  - `"keyboard"` when moving the selection via the keyboard
///  - `"pointer"` when moving the selection through the pointing device
Transaction.userEvent = Annotation.define();
/// Annotation indicating whether a transaction should be added to
/// the undo history or not.
Transaction.addToHistory = Annotation.define();

const DefaultIndentUnit = 2, DefaultTabsize = 4, DefaultSplit = /\r\n?|\n/;
/// The editor state class is a persistent (immutable) data structure.
/// To update a state, you [create](#state.EditorState.t) and
/// [apply](#state.Transaction.apply) a
/// [transaction](#state.Transaction), which produces a _new_ state
/// instance, without modifying the original object.
///
/// As such, _never_ mutate properties of a state directly. That'll
/// just break things.
class EditorState {
    /// @internal
    constructor(
    /// @internal
    config, 
    /// The current document.
    doc, 
    /// The current selection.
    selection, tr = null) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        /// @internal
        this.applying = null;
        this.status = config.statusTemplate.slice();
        if (tr && !tr.reconfigured) {
            this.values = tr.startState.values.slice();
        }
        else {
            this.values = config.dynamicSlots.map(_ => null);
            // Copy over old values for shared facets/fields if this is a reconfigure
            if (tr)
                for (let id in config.address) {
                    let cur = config.address[id], prev = tr.startState.config.address[id];
                    if (prev != null && (cur & 1) == 0)
                        this.values[cur >> 1] = getAddr(tr.startState, prev);
                }
        }
        this.applying = tr;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.applying = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /// Start a new transaction from this state. When not given, the
    /// timestamp defaults to
    /// [`Date.now()`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now).
    t(timestamp) {
        return new Transaction(this, timestamp);
    }
    /// Join an array of lines using the state's [line
    /// separator](#state.EditorState^lineSeparator).
    joinLines(text) { return text.join(this.facet(EditorState.lineSeparator) || "\n"); }
    /// Split a string into lines using the state's [line
    /// separator](#state.EditorState^lineSeparator).
    splitLines(text) { return text.split(this.facet(EditorState.lineSeparator) || DefaultSplit); }
    /// Get the value of a state [behavior](#extension.Behavior).
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /// Convert this state to a JSON-serializable object.
    toJSON() {
        // FIXME plugin state serialization
        return {
            doc: this.joinLines(this.doc.sliceLines(0, this.doc.length)),
            selection: this.selection.toJSON()
        };
    }
    /// Deserialize a state from its JSON representation.
    static fromJSON(json, config = {}) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions
        });
    }
    /// @internal
    applyTransaction(tr) {
        let reconf = tr.reconfigureData, config = reconf ? Configuration.resolve(reconf.base, reconf.replaced, this) : this.config;
        return new EditorState(config, tr.doc, tr.selection, tr);
    }
    /// Create a new state. You'll usually only need this when
    /// initializing an editor—updated states are created by applying
    /// transactions.
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || []);
        let doc = config.doc instanceof Text ? config.doc
            : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = config.selection || EditorSelection.single(0);
        checkSelection(selection, doc);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection);
    }
    /// The size (in columns) of a tab in the document, determined by
    /// the [`tabSize`](#state.EditorState^tabSize) behavior.
    get tabSize() { return this.facet(EditorState.tabSize); }
    /// The size of an indent unit in the document. Determined by the
    /// [`indentUnit`](#state.EditorState^indentUnit) facet.
    get indentUnit() { return this.facet(EditorState.indentUnit); }
    /// Get the syntax tree for this state, which is the current
    /// (possibly incomplete) parse tree of the [syntax](#state.Syntax)
    /// with the highest precedence, or the empty tree if there is no
    /// syntax available.
    get tree() {
        let syntax = this.facet(EditorState.syntax);
        return syntax.length ? syntax[0].getTree(this) : Tree.empty;
    }
}
/// A facet that, when enabled, causes the editor to allow multiple
/// ranges to be selected. You should probably not use this
/// directly, but let a plugin like
/// [multiple-selections](#multiple-selections) handle it (which
/// also makes sure the selections are visible in the view).
EditorState.allowMultipleSelections = allowMultipleSelections;
/// Facet that defines a way to query for automatic indentation
/// depth at the start of a given line.
EditorState.indentation = Facet.define();
/// Configures the tab size to use in this state. The first
/// (highest-precedence) value of the behavior is used.
EditorState.tabSize = Facet.define({
    combine: values => values.length ? values[0] : DefaultTabsize
});
/// The line separator to use. By default, any of `"\n"`, `"\r\n"`
/// and `"\r"` is treated as a separator when splitting lines, and
/// lines are joined with `"\n"`.
///
/// When you configure a value here, only that precise separator
/// will be used, allowing you to round-trip documents through the
/// editor without normalizing line separators.
EditorState.lineSeparator = Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
/// Facet for overriding the unit (in columns) by which
/// indentation happens. When not set, this defaults to 2.
EditorState.indentUnit = Facet.define({
    combine: values => values.length ? values[0] : DefaultIndentUnit
});
/// Facet that registers a parsing service for the state.
EditorState.syntax = Facet.define();
/// A facet that registers a code folding service. When called
/// with the extent of a line, it'll return a range object when a
/// foldable that starts on that line (but continues beyond it) can
/// be found.
EditorState.foldable = Facet.define();

/// Utility function for combining behaviors to fill in a config
/// object from an array of provided configs. Will, by default, error
/// when a field gets two values that aren't ===-equal, but you can
/// provide combine functions per field to do something else.
function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined) ; // No conflict
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}
/// Defaults the fields in a configuration object to values given in
/// `defaults` if they are not already present.
function fillConfig(config, defaults) {
    let result = {};
    for (let key in config)
        result[key] = config[key];
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}

export { Annotation, Change, ChangeDesc, ChangeSet, ChangedRange, EditorSelection, EditorState, ExtensionGroup, Facet, MapMode, Precedence, SelectionRange, StateField, Transaction, combineConfig, fillConfig, languageData };
